---
title = "Unreal Engine"
published = "December 17, 2016"
comments = false
---

Unreal Engine is an industry grade, robust game engine. While previous engines offered UnrealScript for implementing new behavior, Unreal Engine 4 uses C++ exclusively along with visual programming "Blueprints" that are generate C++.

<toc/>

# Editor

Pressing <kbd>F</kbd> in the camera pane will move the camera to focus onto the selected object.

Pressing and holding <kbd>ALT</kbd> while dragging left-click will orbit the focused object, while dragging right-click will zoom in and out of the object.

Geometry brushes have built-in behavior for collision, tessellation, and material tiling. They are used to "block out" an environment and then they are converted to static meshes.

A brush face can be selected by holding <kbd>CTRL</kbd> + <kbd>SHIFT</kbd> + left-click on a face. All faces can then be selected by going to the _Geometry_ drop-down and selecting _Select all adjacent faces_.

Objects such as brushes can be duplicated by copy-pasting or by holding <kbd>ALT</kbd> while transforming the object.

Physics simulation can be enabled for an object by going to its _Physics_ section of the _Details_ panel and ticking the _Simulate Physics_ checkbox.

The physics of an object can be constrained to specific planes, such as the YZ-plane, by using the _Constraints_ field in the _Physics_ section of the _Details_ panel.

A _trigger volume_ is one that emits an event if an actor collides with it.

# Directory Structure

A project contains the following directory structure as well as the Unreal Project File <span class="path">.uproject</span> which can be opened in the Unreal Editor.

Assets are stored as <span class="path">.uasset</span> files in the Content folder, and can include Materials, Static and Skeletal Meshes, Blueprints, Sound Cues, Textures, and reusable reference materials and templates.

maps are stored as <span class="path">.umap</span> files within the Content folder. The Unreal Editor works with one map at a time, which is displayed in the Viewport.

The root directory contains the following directories as well as a directory for each game project:

* <span class="path">Engine</span>: engine source, content, etc.
* <span class="path">Templates</span>: project templates
* <span class="path">GenerateProjectFiles.bat</span>: creates UE4 Visual Studio solution
* <span class="path">UE4Games.uprojectdirs</span>: tells UnrealBuildTool where to find projects

Both the Engine and game project directories have some directories in common:

* <span class="path">Binaries</span>: built binaries and other built objects
* <span class="path">Build</span>: build files
* <span class="path">Config</span>: configuration files for engine settings. Those in game project configuration files override those in the Engine directory.
* <span class="path">Content</span>: engine and game content, including asset packages and maps
* <span class="path">DerivedDataCache</span>: cached derived data files generated on-load
* <span class="path">Intermediate</span>: temporary build files, such as shaders in game directories
* <span class="path">Saved</span>: autosaves, configuration files, and logs. The Engine's directory also contains crash logs, hardware information, and more.
* <span class="path">Source</span>: contains engine and game source, tools, gameplay classes, etc.
    * <span class="path">Engine</span>:
        * <span class="path">Developer</span>: source common to editor and engine
        * <span class="path">Editor</span>: editor source
        * <span class="path">Programs</span>: external tools used by engine and editor
        * <span class="path">Runtime</span>: engine source
    * <span class="path">Game</span>: organized with a directory per module, each containing:
        * <span class="path">Classes</span>: gameplay class headers (.h)
        * <span class="path">Private</span>: gameplay class and module implementations (.cpp)
        * <span class="path">Public</span>: module header

The <span class="path">Engine</span> directory also contains:

* <span class="path">Documentation</span>: source markdown and published HTML documentation
* <span class="path">Extras</span>: helper and utility files
* <span class="path">Plugins</span>: engine plugins
* <span class="path">Programs</span>: configuration files and logs for root projects such as UnrealFrontEnd and UnrealHeaderTool
* <span class="path">Shaders</span>: shader source files (.usf)

Each game project directory contains:

* <span class="path">Binaries</span>: built binaries
* <span class="path">Config: </span>default game settings
* <span class="path">Content:</span> engine or game content, including asset packages and maps
* <span class="path">External dependencies</span>: public engine headers (Visual Studio)
* <span class="path">Intermediate</span>: files generated by UnrealBuildTool such as Visual Studio projects
* <span class="path">Saved</span>: configuration files and logs
* <span class="path">Source</span>:
    * <span class="path">Classes</span>: game object class definitions (.h)
    * <span class="path">Private</span>: private game object class implementations (.cpp)
    * <span class="path">Public</span>: public game object class implementations (.cpp)

Solution directories contain:

* <span class="path">Classes</span>: game object class definitions (.h)
* <span class="path">Config</span>: default game settings
* <span class="path">External dependencies</span>: public engine headers (Visual Studio)
* <span class="path">Private</span>: private game object class implementations (.cpp)
* <span class="path">Public</span>: public game object class implementations (.cpp)

# Terminology

The base object type `UObject` implements garbage collection, support for exposing object metadata to the Unreal Editor via the `UProperty` macro, and serialization.

An _Actor_ is any object that can be placed in a level. It supports 3D transformations and can be spawned and destroyed. An actor can be moved with the [`SetActorLocation`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/AActor/SetActorLocation/index.html) method, for example. Example actors include `StaticMeshActor`, `CameraActor`, and `PlayerStartActor`.

A _Component_ encapsulates functionality that can be added to an Actor.

A _Pawn_ is an Actor that can be possessed (controlled) by a player or AI, not assumed to be humanoid. The `DefaultPawn` class contains a spherical `CollisionComponent`, `StaticMeshComponent`, and a `DefaultPawnMovementComponent` with a no-gravity, flying movement style. The `SpectatorPawn` class is a subclass of `DefaultPawn` and is useful for spectating functionality.

A _Character_ is a Pawn that is specifically intended for use by a player (as opposed to an AI). It includes collision setup via `CapsuleComponent`, input bindings, movement behavior via `CharacterMovementComponent`, and some animation-related functionality. Its movement can be replicated smoothly across the network.

A _Controller_ is an Actor that controls a Pawn. Controllers receive notifications for many of the events for the possessed Pawn, allowing it to intercept and even supercede the Pawn's default behavior. A Controller can be made to tick before a Pawn, minimizing latency between input processing and Pawn movement. By default a Controller controls a single Pawn at any given time, but this can be changed for certain games such as RTSes.

A _PlayerController_ is used to translate human input into game interactions through a possessed Pawn or Character. In a multiplayer setting, the server has a PlayerController instance for each player in the game and network calls are routed and processed by the corresponding player's PlayerController. From a player (client)'s perspective they can only communicate with the server through the PlayerController.

A _PlayerController_ can have a heads-up display (HUD), a CameraComponent, a CameraActor which is used to calculate its position and orientation, and a PlayerCameraManager, which as the name suggestions, manages how the player camera behaves.

An _AIController_ is similar to a PlayerController except that it is meant to possess a Pawn that represents an NPC. Note that Pawns and Characters have a base AIController by default unless specifically possessed by a PlayerController or told not to create an AIController.

The _CameraActor_ class is mainly a wrapper for CameraComponent so that it can be placed directly in the level rather than within another class. The CameraComponent has two components to aid in visual placement: a StaticMeshComponent representing the camera's placement and a FrustumComponent representing the camera's field of view, whose appearance must be enabled in the editor under the Viewport's **Show** → **Advanced** → **Camera Frustums** menu.

The _PlayerCameraManager_ by default blends between pending view targets and debug cameras triggered by console commands. It queries the ViewTarget for what to do for the camera's viewpoint. The ViewTarget provides the PlayerCameraManager with the ideal point of view (POV). In order to do this, it maintains information on the target Actor, the Actor's Controller (for non-locally controlled Pawns), and the PlayerState, in order to follow the same player through Pawn transitions while spectating, for example.

A _CameraComponent_ provides the ViewTarget information if a CameraActor or any Actor that contains a CameraComponent and has `bFindCameraComponentWhenViewTarget` set. The camera view is obtained from the first found CameraComponent via an Actor's `CalcCamera` function. If none exists or the property is off, it uses the Actor's location and rotation. A PlayerController also has the `CalcCamera` function which returns the location of the possessed pawn, if one exists, and the control rotation of the PlayerController. One level higher, the `PlayerCameraManager` uses the `UpdateViewTarget` function to query the ViewTarget, returning its Point of View.

Game-specific camera behavior can be provided at any point within the camera responsibility chain beginning with the CameraComponent, then Actor or PlayerController, then PlayerCameraManager.

A _Brush_ is an Actor that describes a 3D volume used to define level geometry (known as BSPs) and gameplay volumes. BSP Brushes are often used to block-out levels. Volume Brushes are often used for Blocking Volumes (invisible; impede Actor passage), Pain Causing Volumes (damage over time on collision), or Trigger Volumes (trigger events on entry/exit).

A _Level_ (aka _Map_) is a user-defined area of gameplay, and are mainly defined by the properties of the Actors contained within them. A level corresponds to a `.umap` file.

A _World_ consists of a list of loaded Levels, and handles streaming the levels and spawning dynamic Actors.

A _GameMode_ is responsible for setting the game rules, such as the maximum number of players, spawn locations and their behavior, whether it can be paused, level transitions, and game-specific behavior like win conditions such as whichever player crosses the finish line first is the winner. The default GameMode can be set in the Project Settings and can be overridden by a Level. In a multiplayer setting, the GameMode only exists on the server and the rules are replicated to each client. It should not have much data that changes during play, and definitely not transient data that clients need to know about.

The default game mode for all maps in a project can be set in the <span class="path">/Script/EngineSettings.GameMapsSettings</span> section of the <span class="path">DefaultEngine.ini</span> configuration file. A specific map's GameMode can be set through the **World Settings** tab with the **GameMode Override** setting. It's also possible to override the game used via the `game` query parameter to the map path given to the game when the `-game` argument is passed. It's also possible to register game modes with map name prefixes. For example, the map name prefix "DM" can be associated with a game mode `UTDMGameMode` by specifying it in the <span class="path">/Script/EngineSettings.GameMapSettings</span> section of the <span class="path">DefaultEngine.ini</span> configuration file with the `+GameModeMapPrefixes` and `+GameModeClassAliases` settings:

``` ini
[/Script/EngineSettings.GameMapsSettings]
+GameModeMapPrefixes=(Name="DM",GameMode="/Script/UnrealTournament.UTDMGameMode")
+GameModeClassAliases=(Name="DM",GameMode="/Script/UnrealTournament.UTDMGameMode")
```

The new `AGameModeBase` (>=4.14) is the base of all GameModes, which itself is a simplified, streamlined version of the original `AGameMode`, which now derives from the new class. The `AGameMode` class is suited for a traditional multiplayer shooter.

The `InitGame` function runs before Actors run their `PreInitializeComponents` function (including the `GameMode` instance, which itself is an `Actor`) and is used to initialize parameters and spawn helper classes.

The `PreLogin` function determines whether to accept or reject a player attempting to join the server. The `PostLogin` function is called after a successful login and can be used to call replicated functions which invoke the `PlayerController::OnPostLogin` handler. The `HandleStartingNewPlayer` is called after `PostLogin` or after a seamless travel and is usually used to create a Pawn for the player. The `RestartPlayer` is used to start spawning the player's Pawn. The `SpawnDefaultPawnAtTransform` function actually performs the spawn. The `Logout` function is called when the player leaves or is destroyed.

It is common to create a separate `GameMode` for each match format, mission type, or special zone, though only one is in use at any given moment, instantiated whenever a level is initialized for play via `UGameEngine::LoadMap`.

Meanwhile, rule-related game events may trigger game state mutations which need to be tracked by all players in a `GameState`. The `GameState` may contain information such as the match duration (beyond when a particular player joined), when a particular player joined, the `GameMode`'s base class, and whether the game has begun. In other words, it should manage information meant to be known to _all_ connected clients that is specific to the `GameMode` but _not_ specific to any particular player.

The base `GameState` class is `AGameStateBase`. Some of the functionality that this class provides is `GetServerWorldTimeSeconds` which yields the server's `UWorld::GetTimeSeconds`, which is synchronized between the server and the client, the `PlayerArray` which is the array of all `APlayerState` objects, which is useful for performing actions on all players, and the `HasBegunPlay` function which determines if the `BeginPlay` function has been invoked on all Actors.

The `PlayerState` contains information specific to a particular player, be it a human player or bot simulating a player (not non-player AI), This information can be the player's name, score, or health. Each player's `PlayerState` is replicated from the server to each client.

![class-diagram](https://i.imgur.com/GtaF8os.jpg)

# User Interface

Heads-up displays (HUD) are generally for non-interactive  game state, while user interfaces are for interactive elements drawn on the screen (like a HUD) or onto a surface in the world.

The `HUD` class is the base object for displaying elements overlaid on the screen. Each human-controlled player has their own instance of the `AHUD` class which draws to their individual Viewport. For example, while a split-screen multiplayer game may have multiple Viewports sharing the same screen, each HUD draws to its own Viewport.

The `Canvas` object can be used in the HUD's render loop to draw low-level elements (text, texture and material tiles, triangles, shapes) to the screen.

[Slate](https://docs.unrealengine.com/latest/INT/Programming/Slate/index.html) is a user interface framework that facilitates the design of user interfaces for tools (e.g. Unreal Editor) or games. It appears that the use of Slate is now preferred over the use of UMG.

[Unreal Motion Graphics UI Designer](https://docs.unrealengine.com/latest/INT/Engine/UMG/index.html) (UMG) is a visual UI authoring tool that can be used to create HUDs, menus, or other interfaces.

# Code Style

Many classes have a prefix character that denotes their expected usage or lineage. Type definitions should have a prefix corresponding to the prefix that would be used on for underlying type. These prefixes are actually expected by UnrealHeaderTool.

* `T`: Template class
* `U`: Inherits from `UObject`
* `A`: Inherits from `AActor`
* `S`: Inherits from `SWidget`
* `I`: Abstract interface
* `E`: Enum
* `b`: Boolean variable
* `F`: most other classes

The Unreal Engine source code style is to keep each brace on its own line.

# Logging

To see logs, the game must be run with the `-Log` argument or the console command `showlog` must be run. When run in the editor, the logs are enabled by default due to the argument being set in `GameCommandLine` in the Engine configuration file, and they will be visible in the **Output Log** window.

Text can be logged with the `UE_LOG` macro. The macro takes a category, verbosity level, and the actual text. For example:

``` cpp
UE_LOG(LogTemp, Warning, TEXT("The message"));
```

The verbosity levels are:

* `Fatal`: Always appear in console and log files even if logging is disabled.
* `Error`: Red. Appear in console and log files.
* `Warning`: Yellow. Appear in console and log files.
* `Display`: Appear in console and log files.
* `Log`: Appear in log files.
* `Verbose`: Appear in log files. Used for detailed logging and debugging.
* `VeryVerbose`: Appear in log files. Used for very detailed logging (like trace)

A log category can be declared with the `DECLARE_LOG_CATEGORY_EXTERN` macro. It takes the category name, its default verbosity, and the compile-time verbosity. The default verbosity sets the threshold past which no logging occurs. The compile-time verbosity sets the threshold past which the logging macro doesn't compile into code.

``` cpp
DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity);
```

The log category should then be defined in the implementation file with the `DEFINE_LOG_CATEGORY` macro.

``` cpp
DEFINE_LOG_CATEGORY(CategoryName);
```

The `UE_LOG` takes variable arguments that can be used for formatting the log message [^fstring_printf].

[^fstring_printf]: This seems to be based on [`FString::Printf`](https://docs.unrealengine.com/latest/INT/API/Runtime/Core/Containers/FString/Printf/index.html).

``` cpp
UE_LOG(MyLog, Warning, TEXT("MyCharacter's Name is %s"), *(MyCharacter->GetName()));
```

More directly, a message can be displayed on the screen with the [`UEngine::AddOnScreenDebugMessage`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html) method. It takes a unique key (to prevent duplicates; -1 for a transient message), its display duration in seconds, the color to use, and the message as an `FString`.

``` cpp
#include <EngineGlobals.h>
#include <Runtime/Engine/Classes/Engine/Engine.h>

FString message = FString::Printf(TEXT("Some variable values: x: %f, y: %f"), x, y);

GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, message);
```

It's also possible to log a message directly to the console through [`APlayerController::ClientMessage`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/APlayerController/ClientMessage/index.html).

