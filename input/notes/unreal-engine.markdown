---
title = "Unreal Engine"
published = "December 17, 2016"
comments = false
---

Unreal Engine is an industry grade, robust game engine. While previous engines offered UnrealScript for implementing new behavior, Unreal Engine 4 uses C++ exclusively along with visual programming "Blueprints" that are generate C++.

<toc/>

# Editor

Pressing <kbd>F</kbd> in the camera pane will move the camera to focus onto the selected object.

Pressing and holding <kbd>ALT</kbd> while dragging left-click will orbit the focused object, while dragging right-click will zoom in and out of the object.

Geometry brushes have built-in behavior for collision, tessellation, and material tiling. They are used to "block out" an environment and then they are converted to static meshes.

A brush face can be selected by holding <kbd>CTRL</kbd> + <kbd>SHIFT</kbd> + left-click on a face. All faces can then be selected by going to the _Geometry_ drop-down and selecting _Select all adjacent faces_.

Objects such as brushes can be duplicated by copy-pasting or by holding <kbd>ALT</kbd> while transforming the object.

Physics simulation can be enabled for an object by going to its _Physics_ section of the _Details_ panel and ticking the _Simulate Physics_ checkbox.

The physics of an object can be constrained to specific planes, such as the YZ-plane, by using the _Constraints_ field in the _Physics_ section of the _Details_ panel.

A _trigger volume_ is one that emits an event if an actor collides with it.

# Directory Structure

A project contains the following directory structure as well as the Unreal Project File <span class="path">.uproject</span> which can be opened in the Unreal Editor.

Assets are stored as <span class="path">.uasset</span> files in the Content folder, and can include Materials, Static and Skeletal Meshes, Blueprints, Sound Cues, Textures, and reusable reference materials and templates.

maps are stored as <span class="path">.umap</span> files within the Content folder. The Unreal Editor works with one map at a time, which is displayed in the Viewport.

The root directory contains the following directories as well as a directory for each game project:

* <span class="path">Engine</span>: engine source, content, etc.
* <span class="path">Templates</span>: project templates
* <span class="path">GenerateProjectFiles.bat</span>: creates UE4 Visual Studio solution
* <span class="path">UE4Games.uprojectdirs</span>: tells UnrealBuildTool where to find projects

Both the Engine and game project directories have some directories in common:

* <span class="path">Binaries</span>: built binaries and other built objects
* <span class="path">Build</span>: build files
* <span class="path">Config</span>: configuration files for engine settings. Those in game project configuration files override those in the Engine directory.
* <span class="path">Content</span>: engine and game content, including asset packages and maps
* <span class="path">DerivedDataCache</span>: cached derived data files generated on-load
* <span class="path">Intermediate</span>: temporary build files, such as shaders in game directories
* <span class="path">Saved</span>: autosaves, configuration files, and logs. The Engine's directory also contains crash logs, hardware information, and more.
* <span class="path">Source</span>: contains engine and game source, tools, gameplay classes, etc.
    * <span class="path">Engine</span>:
        * <span class="path">Developer</span>: source common to editor and engine
        * <span class="path">Editor</span>: editor source
        * <span class="path">Programs</span>: external tools used by engine and editor
        * <span class="path">Runtime</span>: engine source
    * <span class="path">Game</span>: organized with a directory per module, each containing:
        * <span class="path">Classes</span>: gameplay class headers (.h)
        * <span class="path">Private</span>: gameplay class and module implementations (.cpp)
        * <span class="path">Public</span>: module header

The <span class="path">Engine</span> directory also contains:

* <span class="path">Documentation</span>: source markdown and published HTML documentation
* <span class="path">Extras</span>: helper and utility files
* <span class="path">Plugins</span>: engine plugins
* <span class="path">Programs</span>: configuration files and logs for root projects such as UnrealFrontEnd and UnrealHeaderTool
* <span class="path">Shaders</span>: shader source files (.usf)

Each game project directory contains:

* <span class="path">Binaries</span>: built binaries
* <span class="path">Config: </span>default game settings
* <span class="path">Content:</span> engine or game content, including asset packages and maps
* <span class="path">External dependencies</span>: public engine headers (Visual Studio)
* <span class="path">Intermediate</span>: files generated by UnrealBuildTool such as Visual Studio projects
* <span class="path">Saved</span>: configuration files and logs
* <span class="path">Source</span>:
    * <span class="path">Classes</span>: game object class definitions (.h)
    * <span class="path">Private</span>: private game object class implementations (.cpp)
    * <span class="path">Public</span>: public game object class implementations (.cpp)

Solution directories contain:

* <span class="path">Classes</span>: game object class definitions (.h)
* <span class="path">Config</span>: default game settings
* <span class="path">External dependencies</span>: public engine headers (Visual Studio)
* <span class="path">Private</span>: private game object class implementations (.cpp)
* <span class="path">Public</span>: public game object class implementations (.cpp)

# Terminology

The base object type `UObject` implements garbage collection, support for exposing object metadata to the Unreal Editor via the `UProperty` macro, and serialization.

An _Actor_ is any object that can be placed in a level. It supports 3D transformations and can be spawned and destroyed. An actor can be moved with the [`SetActorLocation`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/AActor/SetActorLocation/index.html) method, for example. Example actors include `StaticMeshActor`, `CameraActor`, and `PlayerStartActor`.

A _Component_ encapsulates functionality that can be added to an Actor.

A _Pawn_ is an Actor that can be possessed (controlled) by a player or AI, not assumed to be humanoid. The `DefaultPawn` class contains a spherical `CollisionComponent`, `StaticMeshComponent`, and a `DefaultPawnMovementComponent` with a no-gravity, flying movement style. The `SpectatorPawn` class is a subclass of `DefaultPawn` and is useful for spectating functionality.

A _Character_ is a Pawn that is specifically intended for use by a player (as opposed to an AI). It includes collision setup via `CapsuleComponent`, input bindings, movement behavior via `CharacterMovementComponent`, and some animation-related functionality. Its movement can be replicated smoothly across the network.

A _Controller_ is an Actor that controls a Pawn. Controllers receive notifications for many of the events for the possessed Pawn, allowing it to intercept and even supercede the Pawn's default behavior. A Controller can be made to tick before a Pawn, minimizing latency between input processing and Pawn movement. By default a Controller controls a single Pawn at any given time, but this can be changed for certain games such as RTSes.

A _PlayerController_ is used to translate human input into game interactions through a possessed Pawn or Character. In a multiplayer setting, the server has a PlayerController instance for each player in the game and network calls are routed and processed by the corresponding player's PlayerController. From a player (client)'s perspective they can only communicate with the server through the PlayerController.

A _PlayerController_ can have a heads-up display (HUD), a CameraComponent, a CameraActor which is used to calculate its position and orientation, and a PlayerCameraManager, which as the name suggestions, manages how the player camera behaves.

An _AIController_ is similar to a PlayerController except that it is meant to possess a Pawn that represents an NPC. Note that Pawns and Characters have a base AIController by default unless specifically possessed by a PlayerController or told not to create an AIController.

The _CameraActor_ class is mainly a wrapper for CameraComponent so that it can be placed directly in the level rather than within another class. The CameraComponent has two components to aid in visual placement: a StaticMeshComponent representing the camera's placement and a FrustumComponent representing the camera's field of view, whose appearance must be enabled in the editor under the Viewport's **Show** → **Advanced** → **Camera Frustums** menu.

The _PlayerCameraManager_ by default blends between pending view targets and debug cameras triggered by console commands. It queries the ViewTarget for what to do for the camera's viewpoint. The ViewTarget provides the PlayerCameraManager with the ideal point of view (POV). In order to do this, it maintains information on the target Actor, the Actor's Controller (for non-locally controlled Pawns), and the PlayerState, in order to follow the same player through Pawn transitions while spectating, for example.

A _CameraComponent_ provides the ViewTarget information if a CameraActor or any Actor that contains a CameraComponent and has `bFindCameraComponentWhenViewTarget` set. The camera view is obtained from the first found CameraComponent via an Actor's `CalcCamera` function. If none exists or the property is off, it uses the Actor's location and rotation. A PlayerController also has the `CalcCamera` function which returns the location of the possessed pawn, if one exists, and the control rotation of the PlayerController. One level higher, the `PlayerCameraManager` uses the `UpdateViewTarget` function to query the ViewTarget, returning its Point of View.

Game-specific camera behavior can be provided at any point within the camera responsibility chain beginning with the CameraComponent, then Actor or PlayerController, then PlayerCameraManager.

A _Brush_ is an Actor that describes a 3D volume used to define level geometry (known as BSPs) and gameplay volumes. BSP Brushes are often used to block-out levels. Volume Brushes are often used for Blocking Volumes (invisible; impede Actor passage), Pain Causing Volumes (damage over time on collision), or Trigger Volumes (trigger events on entry/exit).

A _Level_ (aka _Map_) is a user-defined area of gameplay, and are mainly defined by the properties of the Actors contained within them. A level corresponds to a `.umap` file.

A _World_ consists of a list of loaded Levels, and handles streaming the levels and spawning dynamic Actors.

A _GameMode_ is responsible for setting the game rules, such as the maximum number of players, spawn locations and their behavior, whether it can be paused, level transitions, and game-specific behavior like win conditions such as whichever player crosses the finish line first is the winner. The default GameMode can be set in the Project Settings and can be overridden by a Level. In a multiplayer setting, the GameMode only exists on the server and the rules are replicated to each client. It should not have much data that changes during play, and definitely not transient data that clients need to know about.

The default game mode for all maps in a project can be set in the <span class="path">/Script/EngineSettings.GameMapsSettings</span> section of the <span class="path">DefaultEngine.ini</span> configuration file. A specific map's GameMode can be set through the **World Settings** tab with the **GameMode Override** setting. It's also possible to override the game used via the `game` query parameter to the map path given to the game when the `-game` argument is passed. It's also possible to register game modes with map name prefixes. For example, the map name prefix "DM" can be associated with a game mode `UTDMGameMode` by specifying it in the <span class="path">/Script/EngineSettings.GameMapSettings</span> section of the <span class="path">DefaultEngine.ini</span> configuration file with the `+GameModeMapPrefixes` and `+GameModeClassAliases` settings:

``` ini
[/Script/EngineSettings.GameMapsSettings]
+GameModeMapPrefixes=(Name="DM",GameMode="/Script/UnrealTournament.UTDMGameMode")
+GameModeClassAliases=(Name="DM",GameMode="/Script/UnrealTournament.UTDMGameMode")
```

The new `AGameModeBase` (>=4.14) is the base of all GameModes, which itself is a simplified, streamlined version of the original `AGameMode`, which now derives from the new class. The `AGameMode` class is suited for a traditional multiplayer shooter.

The `InitGame` function runs before Actors run their `PreInitializeComponents` function (including the `GameMode` instance, which itself is an `Actor`) and is used to initialize parameters and spawn helper classes.

The `PreLogin` function determines whether to accept or reject a player attempting to join the server. The `PostLogin` function is called after a successful login and can be used to call replicated functions which invoke the `PlayerController::OnPostLogin` handler. The `HandleStartingNewPlayer` is called after `PostLogin` or after a seamless travel and is usually used to create a Pawn for the player. The `RestartPlayer` is used to start spawning the player's Pawn. The `SpawnDefaultPawnAtTransform` function actually performs the spawn. The `Logout` function is called when the player leaves or is destroyed.

It is common to create a separate `GameMode` for each match format, mission type, or special zone, though only one is in use at any given moment, instantiated whenever a level is initialized for play via `UGameEngine::LoadMap`.

Meanwhile, rule-related game events may trigger game state mutations which need to be tracked by all players in a `GameState`. The `GameState` may contain information such as the match duration (beyond when a particular player joined), when a particular player joined, the `GameMode`'s base class, and whether the game has begun. In other words, it should manage information meant to be known to _all_ connected clients that is specific to the `GameMode` but _not_ specific to any particular player.

The base `GameState` class is `AGameStateBase`. Some of the functionality that this class provides is `GetServerWorldTimeSeconds` which yields the server's `UWorld::GetTimeSeconds`, which is synchronized between the server and the client, the `PlayerArray` which is the array of all `APlayerState` objects, which is useful for performing actions on all players, and the `HasBegunPlay` function which determines if the `BeginPlay` function has been invoked on all Actors.

The `PlayerState` contains information specific to a particular player, be it a human player or bot simulating a player (not non-player AI), This information can be the player's name, score, or health. Each player's `PlayerState` is replicated from the server to each client.

![class-diagram](https://i.imgur.com/GtaF8os.jpg)

# User Interface

Heads-up displays (HUD) are generally for non-interactive  game state, while user interfaces are for interactive elements drawn on the screen (like a HUD) or onto a surface in the world.

The `HUD` class is the base object for displaying elements overlaid on the screen. Each human-controlled player has their own instance of the `AHUD` class which draws to their individual Viewport. For example, while a split-screen multiplayer game may have multiple Viewports sharing the same screen, each HUD draws to its own Viewport.

The `Canvas` object can be used in the HUD's render loop to draw low-level elements (text, texture and material tiles, triangles, shapes) to the screen.

[Slate](https://docs.unrealengine.com/latest/INT/Programming/Slate/index.html) is a user interface framework that facilitates the design of user interfaces for tools (e.g. Unreal Editor) or games. It appears that the use of Slate is now preferred over the use of UMG.

[Unreal Motion Graphics UI Designer](https://docs.unrealengine.com/latest/INT/Engine/UMG/index.html) (UMG) is a visual UI authoring tool that can be used to create HUDs, menus, or other interfaces.

# Code Style

Many classes have a prefix character that denotes their expected usage or lineage. Type definitions should have a prefix corresponding to the prefix that would be used on for underlying type. These prefixes are actually expected by UnrealHeaderTool.

* `T`: Template class
* `U`: Inherits from `UObject`
* `A`: Inherits from `AActor`
* `S`: Inherits from `SWidget`
* `I`: Abstract interface
* `E`: Enum
* `b`: Boolean variable
* `F`: most other classes

The Unreal Engine source code style is to keep each brace on its own line.

# Logging

To see logs, the game must be run with the `-Log` argument or the console command `showlog` must be run. When run in the editor, the logs are enabled by default due to the argument being set in `GameCommandLine` in the Engine configuration file, and they will be visible in the **Output Log** window.

Text can be logged with the `UE_LOG` macro. The macro takes a category, verbosity level, and the actual text. For example:

``` cpp
UE_LOG(LogTemp, Warning, TEXT("The message"));
```

The verbosity levels are:

* `Fatal`: Always appear in console and log files even if logging is disabled.
* `Error`: Red. Appear in console and log files.
* `Warning`: Yellow. Appear in console and log files.
* `Display`: Appear in console and log files.
* `Log`: Appear in log files.
* `Verbose`: Appear in log files. Used for detailed logging and debugging.
* `VeryVerbose`: Appear in log files. Used for very detailed logging (like trace)

A log category can be declared with the `DECLARE_LOG_CATEGORY_EXTERN` macro. It takes the category name, its default verbosity, and the compile-time verbosity. The default verbosity sets the threshold past which no logging occurs. The compile-time verbosity sets the threshold past which the logging macro doesn't compile into code.

``` cpp
DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity);
```

The log category should then be defined in the implementation file with the `DEFINE_LOG_CATEGORY` macro.

``` cpp
DEFINE_LOG_CATEGORY(CategoryName);
```

The `UE_LOG` takes variable arguments that can be used for formatting the log message [^fstring_printf].

[^fstring_printf]: This seems to be based on [`FString::Printf`](https://docs.unrealengine.com/latest/INT/API/Runtime/Core/Containers/FString/Printf/index.html).

``` cpp
UE_LOG(MyLog, Warning, TEXT("MyCharacter's Name is %s"), *(MyCharacter->GetName()));
```

More directly, a message can be displayed on the screen with the [`UEngine::AddOnScreenDebugMessage`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html) method. It takes a unique key (to prevent duplicates; -1 for a transient message), its display duration in seconds, the color to use, and the message as an `FString`.

``` cpp
#include <EngineGlobals.h>
#include <Runtime/Engine/Classes/Engine/Engine.h>

FString message = FString::Printf(TEXT("Some variable values: x: %f, y: %f"), x, y);

GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, message);
```

It's also possible to log a message directly to the console through [`APlayerController::ClientMessage`](https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/APlayerController/ClientMessage/index.html).

# Unreal Build System

The UnrealHeaderTool (UHT) does custom parsing and code-generation to facilitate the `UObject` system. First when UHT is invoked, C++ headers are parsed for Unreal-related class metadata in order to generate custom code to implement the various `UObject` features. Then the regular C++ compiler is invoked to compile the resulting code.

Each engine module has its own <span class="path">.build.cs</span> file that controls how it is built by defining module dependencies, libraries to link, additional include paths, etc. Each module is compiled into shared libraries (DLLs on Windows) and loaded by a single binary. Instead of shared libraries, each module can be statically linked into the binary via the <span class="path">BuildConfiguration.cs</span> file.

The Unreal Build System's build process executes _independently_ of IDE project files (<span class="path">.sln</span> or <span class="path">.vcproj</span>), which are mainly used for editing purposes, and are generated dynamically based on the project source tree with the <span class="path">GenerateProject.bat</span> script.

The UnrealBuildTool (UBT) supports the following targets:

* Game: standalone game, requires cooked data
* Client: "Game" target without server code; for network clients
* Server: "Game" target without client code; for dedicated servers
* Editor: for extending the Unreal Editor
* Program: for standalone utility programs built on UE

Targets are declared in <span class="path">.target.cs</span> files within the <span class="path">Source/</span> directory. Such a file declares a class deriving from the `TargetRules` class, with properties set in its constructor for how it should be built. When UBT is asked to build a target, it compiles the eponymous file and instantiates the class to determine its settings.

# Engine Architecture

## Object System

Marking classes, properties, and functions with the corresponding Unreal macros turns them into `UClass`s, `UProperty`s, and `UFunction`s, which exposes them to the Unreal Engine.

`UObject`s are automatically zeroed on initialization _before_ their constructors are invoked, both native members and `UProperty`s.

### Garbage Collection

The engine maintains a reference graph of `UObjects` that are periodically flagged for destruction. The "root set" consists of the objects at the root of the graph. Any `UObject` can be added to the root set. Any `UObjects` not found in the reference graph are assumed unneeded and will be removed. This can be done in a separate thread, known as multithreaded reachability analysis.

Objects can be retained by marking them as a `UProperty` or keeping them in an engine container such as `TArray`. Actors are usually referenced by an Object that is directly or indirectly linked to the root set, such as through a Level in which they were placed, while their Components are linked to the root set through the Actor that they belong to.

Actors can be explicitly marked for destruction through the `AActor::Destroy` function, while Components have the `UActorComponent::DestroyComponent` function.

All references to a destroyed or otherwise removed `AActor` or `UActorComponent` that is visible to the reflection system are automatically nulled, including `UProperty`s and those stored in Unreal Engine containers such as `TArray`, so as to prevent dangling pointers from persisting. A weak pointer can be created via `TWeakObjectPtr` for cases where an Object pointer should not be a `UProperty`.

All references to a `UObject` `UProperty` are also nulled when an asset is "Force Deleted" within the Editor.

By default the garbage collector clusters `UObject`s so that an entire cluster is checked instead of each individual Object, which generally improves garbage collection performance and decreases time spent on reachability analysis.

Furthermore, clusters can optionally be merged when one Object references an Object in another. This is irreversible, so that even if the reference that caused the merge is severed, the cluster remains. This may prevent collection in some cases since any reference to any object within the cluster will keep the entire cluster from being collected.

Actors can merged into clusters if the feature is enabled and the actor opts-in by setting its `bCanBeInCluster` property or overriding the `CanBeInCluster` function to return `true`. This is usually useful for Actors that are expected to be destroyed all at once, such as indestructible static meshes that are only destroyed by unloading the level. By default only StaticMeshActors and Reflection Capture Components opt-in.

It's also possible to configure the amount of time between collections, which generally decreases the likely amount of unreachable objects that will be discovered in the next reachability analysis pass.

### Run-Time Type Information

`UObjects` know their `UClass`, which facilitates run-time type checking and casting.

``` cpp
class ALegendaryWeapon : public AWeapon
{
  void SlayMegaBoss()
  {
    TArray<AEnemy> EnemyList = GetEnemyList();

    // The legendary weapon is only effective against the MegaBoss
    for (AEnemy Enemy : EnemyList)
    {
      AMegaBoss* MegaBoss = Cast<AMegaBoss>(Enemy);

      if (MegaBoss)
      {
        Incinerate(MegaBoss);
      }
    }
  }
};
```

Each `UObject` has a `typedef` named `Super` that is set to its parent class, which can be used to invoke behavior in the parent class.

``` cpp
class AEnemy : public ACharacter
{
  virtual void Speak()
  {
    Say("Time to fight!");
  }
};

class AMegaBoss : public AEnemy
{
  // "Powering up! Time to fight!"
  virtual void Speak()
  {
    Say("Powering up! ");
    Super::Speak();
  }
};
```

### Serialization

Serializing `UObject`s consists of serializing its `UProperty` values unless they're marked `Transient` or if they are unchanged from the post-constructor default value. Any `UProperty`s that were added receive default values from the CDO, while those removed are simply ignored.

Custom behavior can be defined by overriding the `UObject::Serialize` function, which is often used for detecting data errors, checking version numbers, or performing data migrations.

When a `UClass`'s CDO is changed, the engine attempts to apply those changes to future instances when they are loaded as long as the instance's copy of the member that was changed in the CDO has the previous CDO's value (i.e. the previous default), otherwise it's assumed that the instance explicitly requested a non-default value for a reason.

## Network Replication

`UProperty`s can marked for network replication. A common flow is for the server to change a variable, then for the Engine to detect and replicate the change to all clients, each of which can optionally receive a callback function when the variable changes via replication.

`UFunction`s can also be marked to execute on a remote machine. For example, a function marked `Server` that is called on a client causes that function to be invoked on the server, and vice versa.

## Gameplay Modules

Each game is modular just like the engine is. Each gameplay module is a collection of related classes usually resulting in shared libraries (just like engine modules). At the very least, each gameplay module must have a header file, implementation file, and build file.

Multiple gameplay modules may result in better link times and faster code iteration at the expense of more interfacing glue code.

<span class="path">MyGame/Source/MyModule/Public/MyModule.h</span>:

``` cpp
#include "Engine.h"
#include "EnginePrivate.h"
#include "MyModuleClasses.h" // UHT-generated
```

<span class="path">MyGame/Source/MyModule/Private/MyModule.cpp</span>:

``` cpp
// Include our game's header file
#include "MyModule.h"

// Designate the module as primary
IMPLEMENT_PRIMARY_GAME_MODULE(MyModule, "MyGame");
```

<span class="path">MyGame/Source/MyModule/MyModule.build.cs</span>:

``` csharp
using UnrealBuildTool;

public class MyModule : ModuleRules
{
    public MyModule(TargetInfo Target)
    {
        PublicDependencyModuleNames.AddRange(new string[] { "Core", "Engine" });
        PrivateDependencyModuleNames.AddRange(new string[] { "RenderCore" });
    }
}
```

The module must then be registered in the <span class="path">DefaultEngine.ini</span> configuration file.

In the `EditPackages` array of the `UnrealEd.EditorEngine` section:

``` ini
[UnrealEd.EditorEngine]
+EditPackages=MyModule
```

The `Launch` section:

``` ini
[Launch]
Module=MyModule
```

And the `NativePackages` array of the <span class="path">/Script/Engine.UObjectPackages</span> section:

``` ini
[/Script/Engine.UObjectPackages]
+NativePackages=MyModule
```

## Gameplay Classes

Each gameplay class has a header and implementation. Using the C++ Class Wizard automatically creates the header and implementation files and configures the game module. By convention, the file names _omit_ the Unreal Engine standard prefixes, so that `AActor` is defined in <span class="path">Actor.h</span>, although the engine places no formal relationship between the class and file name.

Each gameplay class header should include, as the final inclusion, the UHT-generated header file named after the class in question with a <span class="path">.generated</span>. infix marker, so that <span class="path">MyClass.h</span> would include <span class="path">MyClass.generated.h</span>.

A class is registered with Unreal Engine through the `UCLASS()` macro which describes how the class' corresponding `UClass` should be constructed.

The `Abstract` class specifier prevents the user from creating instances of that class, which includes adding Actors of that class with the Unreal Editor. An example would be `ATriggerBase`.

The `Blueprintable` class and interface specifier exposes the class as an acceptable base class for a Blueprint. The default is `NotBlueprintable`. Inherited.

The `BlueprintType` class specifier exposes the class as a type that can be used for variables in Blueprints.

The `ClassGroup` class specifier can be used to specify the group name under which to show this class in the Actor Browser.

The `Config` class specifier indicates that the class can store data in a configuration file for any configurable variables in the class declared with the `config` or `globalconfig` variable specifiers.

The `Const` class specifier indicates that _all_ properties and functions in the class are `const` and should be exported as `const`. Inherited.

The `DefaultToInstanced` class specifier indicates that all instances should be considered "instanced," which are duplicated upon construction. Inherited.

The `DependsOn` class and interface specifier can be used to specify one or more classes that are compiled before this class. This is useful when using structs or enums declared in another class.

The `Deprecated` class specifier marks the class as deprecated, and objects of that class will not be saved when serializing (presumably because it may not be possible to read it back). Inherited.

The `MinimalAPI` class and interface specifier causes only the type information to be exported for use by other modules, so that they can cast to it but not invoke its functions (besides inline methods), which improves compile times.

The `PerObjectConfig` class specifier indicates that the object's configuration will be stored per-object where each object will have its own section named `[ObjectName ClassName]`. Inherited.

The `Placeable` class specifier indicates that the class can be created and placed within a level, UI scene, or Blueprint (depending on the class type). Inherited. Can override with `NonPlaceable`.

The `Transient` class specifier indicates that objects of this class should never be persisted to disk, particularly for use with native classes that are non-persistent by nature, such as players or windows. Inherited. Can override with `NonTransient`.

The `Within` class specifier indicates that its objects cannot exist outside of an instance of the given class name, so that in order to instantiate this class, an instance of the given class name must be specified as its `Outer` object.

The `BlueprintSpawnableComponent` class metadata specifier allows the component class to be spawned by a Blueprint.

The `GENERATED_BODY()` macro must be at the very top of the class definition for the UHT to inject the generated code.

The `UCLASS` macro gives a `UObject` a reference to a `UClass` that contains a set of properties and functions that describe its Unreal-based type. The `UClass` keeps an object called the Class Default Object (CDO) which is an object initialized by the `UObject` constructor which serves as the "template object," an object whose properties are copied to every new instance of that `UObject`.

Objects are automatically garbage collected. The `MarkPendingKill` function nullifies all pointers to the object and then deletes the object on the next garbage collection.

The `UClass` and the CDO can be retrieved for any object, but they should be considered read-only. The `UClass` is accessible through the `GetClass` function.

``` cpp
UCLASS([specifier, …], [meta(key=value, …)])
class ClassName : public ParentName
{
  GENERATED_BODY()
}
```

The constructors are used to set default values for properties and necessary initialization. They're generally defined in the implementation file, but they can be defined inline in the class declaration, in which case the `CustomConstructor` specifier must be passed to its `UCLASS()` invocation to prevent the UHT from generating a corresponding declaration which would clash with the inline definition.

A constructor variant can take an `FObjectInitializer` which can be used to override properties and sub-objects. For example, the following prevents the superclass of `AMyObject` from creating the sub-objects named `"SomeComponent"` and `"SomeOtherComponent"`.

``` cpp
AMyObject::AMyObject(const FObjectInitializer& ObjectInitializer)
  : Super(ObjectInitializer
            .DoNotCreateDefaultSubobject(TEXT("SomeComponent"))
            .DoNotCreateDefaultSubobject(TEXT("SomeOtherComponent")))
{
    // Initialize CDO properties here.
}
```

`UObject` provides the following functionality:

* garbage collection
* reference updating
* reflection
* serialization
* automatic updating of default property changes
* automatic property initialization
* editor integration
* run-time type information
* network replication

`UObject`s can be instantiated in a variety of ways.

The `NewObject<Type>()` function instantiates with an auto-generated name and takes as optional parameters the object's `Outer` and the `UClass` to instantiate, which by default is determined by the template type parameter.

``` cpp
template<class T>
T *NewObject
(
  // The object's Outer.
  UObject *Outer (UObject *)GetTransientPackage(),

  // The UClass to instantiate.
  UClass *Class = T::StaticClass()
)
```

The `NewNamedObject<Type>()` function instantiates with the specified name. It takes as parmeters the object's `Outer`, the name to use, optional object flags, and the template object to use as the CDO. It asserts that the name conflicts with the instance's `Outer`.

``` cpp
template<class T>
T *NewNamedObject
(
  UObject *Outer,

  // The object name.
  FName Name,

  // Object flags.
  EObjectFlags Flags = RF_NoFlags,

  // Archetype object which is treated as the CDO.
  UObject const *Template=NULL
)
```

The `ConstructObject<Type>()` function instantiates with all available creation options for maximum flexibility. It calls `StaticConstructionObject` which allocates the object, calls its `ClassConstructor`, and performs any further initialization such as loading configuration or localization properties and instancing components.

``` cpp
template<class T>
T* ConstructObject
(
  UClass *Class,
  UObject *Outer = (UObject *)GetTransientPackage(),
  FName Name = NAME_None,
  EObjectFlags SetFlags = RF_NoFlags,
  UObject const *Template = NULL,

  // If true, copy transients from CDO instead of from Template archetype object.
  bool bCopyTransientsFromClassDefaults false,

  // Contains mappings of instanced objects and components to their templates.
  // For instancing components owned by the new object.
  struct FObjectInstancingGraph *InstanceGraph = NULL
)
```

The `EObjectFlags` enumeration can be used to describe the spawned Object. It can be used to control the type of object being created (e.g. CDO, transient), its garbage collection behavior (e.g. part of root set, unreachable), and its lifetime phase (e.g. needs loading, being loaded, pending destruction).

It's also possible to instantiate a `UObject` using a direct `new` operator invocation, which allows for passing constructor arguments.

Hard-coded asset references are discouraged due to their brittle nature. To avoid looking-up assets on each constructor call (which involves searching), it is done once and cached through a `ConstructorStatics` struct, which is created once and then simply referenced by subsequent instantiations. The `ConstructorHelpers` namespace contains the `FObjectFinder` function which can be used to find an asset.

``` cpp
ATimelineTestActor::ATimelineTestActor()
{
  // One-time initialization
  struct FConstructorStatics
  {
    ConstructorHelpers::FObjectFinder<UStaticMesh> Object0;
    FConstructorStatics()
      : Object0(TEXT("StaticMesh'/Game/Mesh/S_Health.S_Health'")) {}
  };
  static FConstructorStatics ConstructorStatics;

  // Property initialization
  StaticMesh = ConstructorStatics.Object0.Object;
}
```

Similarly, the `ConstructorHelper::FClassFinder` can be used to find a reference to a particular `UClass`. Although it's usually possible and easier to just use the class's `StaticClass` function which yields the `UClass`, e.g. `USomeClass::StaticClass()`, unless it's a cross-module reference.

``` cpp
APylon::APylon(const class FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
  // Structure to hold one-time initialization
  static FClassFinder<UNavigationMeshBase> ClassFinder(
    TEXT("class'Engine.NavigationMeshBase'"));

  if (ClassFinder.Succeeded())
  {
    NavMeshClass = ClassFinder.Class;
  }
  else
  {
    NavMeshClass = nullptr;
  }
}
```

When an Actor is spawned, all of its components are cloned from the CDO, so they must be added to the object graph, so that they may be properly garbage collected, by keeping a reference to them within the class, which should be stored as a `UPROPERTY`.

``` cpp
UCLASS()
class AWindPointSource : public AActor
{
  GENERATED_BODY()

  public:
  UPROPERTY()
  UWindPointSourceComponent* WindPointSource;

  UPROPERTY()
  UDrawSphereComponent* DisplaySphere;
};
```

It's then possible to create component sub-objects and attach them to the Actor's hierarchy. It's also possible to access and/or modify the parent components via `GetAttachParent`, `GetParentComponents`, `GetNumChildrenComponents`, `GetChildrenComponents`, and `GetChildComponent` on any `USceneComponent` including the root component.

``` cpp
AWindPointSource::AWindPointSource()
{
  // Create a new component named "WindPointSourceComponent0.
  WindPointSource = CreateDefaultSubobject<UWindPointSourceComponent>(
    TEXT("WindPointSourceComponent0"));

  // Set our new component as the RootComponent of this actor,
  // or attach it to the root if one already exists.
  if (RootComponent == nullptr)
  {
    RootComponent = WindPointSource;
  }
  else
  {
    WindPointSource->AttachTo(RootComponent);
  }

  // Attach this component to the component we just created.
  DisplaySphere = CreateDefaultSubobject<UDrawSphereComponent>(
    TEXT("DrawSphereComponent0"));

  DisplaySphere->AttachTo(RootComponent);

  // Set some properties on the new component.
  DisplaySphere->ShapeColor.R = 173;
  DisplaySphere->ShapeColor.G = 239;
  DisplaySphere->ShapeColor.B = 231;
  DisplaySphere->ShapeColor.A = 255;
  DisplaySphere->AlwaysLoadOnClient = false;
  DisplaySphere->AlwaysLoadOnServer = false;
  DisplaySphere->bAbsoluteScale = true;
}
```

# Functions

Functions can be marked up with the `UFUNCTION` macro which, like `UCLASS`, accepts function specifiers. Assuming that the appropriate function specifiers are set, these functions could be:

* called and overridden from Blueprints.
* assigned as delegates within the default properties of a class.
* used as replication callbacks, which are invoked when the associated variable changes.
* executed through the console.

``` cpp
UFUNCTION([specifier, …], [meta(key=value, …)])
ReturnType FunctionName([Parameter, …])
```

Parameters can be marked up with the `UPARAM` macro.

The `ref` param specifier marks a reference parameter as an input parameter as opposed to the assumed output parameter.

The `DisplayName` param specifier specifies how the parameter should appear in the Blueprint editor.

It's possible to add function parameter specifiers `out` or `optional`. The `out` specifier declares the parameter as being passed by reference, allowing it to be modified by the function. The `optional` specifier marks certain parameters as optional, and an optional default value can be specified with the usual C++ syntax for default arguments.

The `BlueprintAuthorityOnly` function specifier prevents the function from running in a Blueprint if running on something that lacks network authority.

The `BlueprintCallable` function specifier allows the function to be called from a Blueprint or a Level Blueprint.

The `BlueprintCosmetic` function specifier prevents the function from running on dedicated servers.

The `BlueprintImplementableEvent` function specifier allows the function to be overridden in a Blueprint or Level Blueprint.

The `BlueprintNativeEvent` function specifier allows the function to be overridden by a Blueprint but _also_ has a default native implementation. The native implementation is defined by a function of the same name with an `_implementation` suffix, which the generated code automatically calls when necessary. These are more costly than `BlueprintImplementableEvent`.

The `BlueprintPure` function specifier allows the function to be called from a Blueprint or Level Blueprint and assures that the function does not affect the owning object or any other global state.

The `Category` function specifier can be used to specify the category under which to display the function in the Blueprint editor, with a vertical bar `|` separating the major and sub-category.

The `Client` function specifier indicates that the function is only executed on the client that owns the Object that the function belongs to. A native implementation can be defined as with `BlueprintNativeEvent`,

The `CustomThunk` function specifier can be used to manually define the `execSomeFunc` thunk function that executes the native implementation of functions marked `BlueprintNativeEvent` or `Client`.

The `Exec` function specifier indicates that the function can be called from the in-game console. This only works for functions within certain classes.

The `NetMulticast` function specifier indicates that the function is executed on the server and replicated to all clients regardless of the Actor's NetOwner.

The `Reliable` function specifier indicates that the function should be replicated over the network in a guaranteed manner [^reliable_tcp] regardless of badnwidth or network errors.

[^reliable_tcp]: As if it's done via TCP or some other reliability protocol over UDP.

The `Unrealiable` function specifier indicates that the function should be replicated over the network without any guarantees.

The `Sserver` function specifier indicates that the function is only executed on the server. A native implementation can be defined as with `BlueprintNativeEvent`,

There are also function metadata specifiers.

The `BlueprintInternalUseOnly` function metadata specifier marks the function as an internal implementation detail used to implement another function or node, so as not to directly expose it in a graph.

The `BlueprintProtected` function metadata specifier restricts the function call on the Blueprint's `this`, so that it cannot be called on another instance.

The `DeprecatedFunction` function metadata specifier marks the function as deprecated so that any Blueprint references cause a compilation warning. The deprecation warning message can be customized via the `DeprecationMessage` function metadata specifier.

The `UnsafeDuringActorConstruction` function metadata specifier marks the function as unsafe to call during Actor construction.

# Structs

Structs can be marked with the `USTRUCT` macro. The generated body is inserted via the `GENERATED_BODY` macro.

``` cpp
USTRUCT([Specifier, …])
struct StructName
{
  GENERATED_BODY()
};
```

The `Atomic` struct specifier indicates that the struct must be serialized as a single unit.

The `BlueprintType` struct specifier allows the struct to be used for variables in Blueprints.

The `NoExport` struct specifier indicates that no code be generated for the struct, so that the header is only provided to parse metadata from.

# Interfaces

Interfaces are declared with a regular `U`-prefixed class that inherits from the `UInterface` class and is marked with the `UINTERFACE` macro.

``` cpp
UINTERFACE([specifier, …], [meta(key=value, …)])
class UClassName : public UInterface
{
  GENERATED_BODY()
};
```

This class is not an actual interface, but merely an empty class that simply exists for Unreal Engine's reflection system's purposes. The actual implementation for the interface is expected in a class named with an `I` prefix instead of a `U` prefix.

``` cpp
#pragma once

#include "ReactToTriggerInterface.generated.h"

UINTERFACE(Blueprintable)
class UReactToTriggerInterface : public UInterface
{
  GENERATED_BODY()
};

// Note that the actual implementation uses an I-prefix
class IReactToTriggerInterface
{
  GENERATED_BODY()

public:
  // React to a trigger volume activating this object.
  // Return true if the reaction succeeds.
  UFUNCTION(BlueprintCallable, BlueprintImplementableEvent,
            Category="Trigger Reaction")
  bool ReactToTrigger() const;
};
```

Any class wishing to implement the interface must derive from the interface implementation class with the `I`-prefix.

``` cpp
class ATrap : public AActor, public IReactToTriggerInterface
{
  GENERATED_BODY()

public:
  virtual bool ReactToTrigger() const override;
};
```

It's possible to dynamically test if a given class implements an interface via the `U`-prefix interface's `UClass`'s `ImplementsInterface` function or by attempting to cast to the interface's _implementation_ type (`I`-prefix).

``` cpp
bool bIsImplemented = Object->GetClass()->ImplementsInterface(UReactToTriggerInterface::StaticClass());

// null if it doesn't implement the interface
IReactToTriggerInterface* ReactingObject = Cast<IReactToTriggerInterface>(Object);
```

More generally, it's possible to cast from one interface to another provided that the object implements both.

``` cpp
// ReactingObject will be non-null if the interface is implemented.
IReactToTriggerInterface* ReactingObject = Cast<IReactToTriggerInterface>(Object);

// non-null if ReactingObject is non-null and also implements IOtherInterface.
IOtherInterface* OtherInterface = Cast<IOtherInterface>(ReactingObject);

// non-null if ReactingObject is non-null and Object is an AActor or AActor-derived class.
AActor* Actor = Cast<AActor>(ReactingObject);
```

The `CannotImplementInterfaceInBlueprint` interface metadata specifier prevents the interface from being implemented by a Blueprint. This is useful if it has only non-exposed C++ methods, for example. More generally, if the interface has any functions that aren't `BlueprintImplementableEvent` or `BlueprintNativeEvent` then it must be marked as `CannotImplementInterfaceInBlueprint`, since the Blueprint would be unable to implement those methods.

## Properties

Class properties can be marked up with the `UPROPERTY` macro.

``` cpp
UPROPERTY([specifier, …], [meta(key=value, …)])
VariableType VariableName;
```

By convention, integers should use types which designate their size, such as `uint64` or `int32`.

Integer properties can be exposed to the Editor as bitmasks by using the `Meta` property `Bitmask`. This causes the Editor to show a generically-named entry in a drop-down for each possible flag for that integer width.

An integer property designated as a `Bitmask` can also be associated with an enumeration, so that each enumeration is displayed in the drop-down.

``` cpp
UENUM(Meta = (Bitflags))
enum class EColorBits
{
  ECB_Red,
  ECB_Green,
  ECB_Blue
};

// In class
UPROPERTY(Editanywhere, Meta = (Bitmask, BitmaskEnum = "EColorBits"))
int32 ColorFlags;
```

The Editor interprets Boolean values to be `bool` or a bit-field.

Four core string types are supported.

* `FString` which is a dynamically-sized string similar to `std::string`
* `FName` which is an interned, immutable, case-insensitive string
* `FText` which is a robust string representation that supports localization

The `TCHAR` type is used for characters. The `TEXT()` macro is used to denote string literals made up of `TCHAR`.

There are a variety of property specifiers that control how the property should behave.

The `AdvanceDisplay` property specifier puts the property in the Advanced drop-down in the Editor.

The `AssetRegistrySearchable` property specifier automatically adds the property to the asset registry for any asset class instance containing the property. Does not apply to structs or parameters.

The `BlueprintAssignable` property specifier only applies to multi-cast delegates and serves to expose the property for assigning in Blueprints.

``` cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnItemRemoved, FItemStruct, RemovedItem);

UCLASS(meta=(BlueprintSpawnableComponent))
class UInventoryComponent : public UActorComponent
{
  GENERATED_BODY()

public:
  UPROPERTY(BlueprintAssignable)
  FOnItemRemoved OnItemRemoved;
};
```

The `BlueprintReadOnly` property specifier indicates that the property can be read by Blueprints but not modified.

The `BlueprintReadWrite` property specifier indicates that the property can be read _and_ written by a Blueprint.

The `Category` property specifier specifies the category that the property should appear under in the Editor, with nested categories delimited by a vertical bar `|`.

The `Config` property specifier makes the property configurable, so that its current value can be saved in a configuration file and loaded when created. As a result, it cannot be given a value in default properties. This implied `ReadOnly`.

The `GlobalConfig` property specifier works like the `Config` property specifier except that it cannot be overridden in a subclass.

The `BlueprintCallable` property specifier only applies to multi-cast delegates and serves to expose the delegate for calling from Blueprints.

The `Const` property specifier indicates that the variable is `const` and should be exported as `const`, so that it will not be modifiable in the editor.

The `DuplicateTransient` property specifier specifies that the variable's value should be reset to the CDO's value whenever the object is copied (e.g. copy-pasted, binary duplication).

The `EditAnywhere` property specifier specifies that the property can be edited by property windows on archetypes and instances.

The `EditDefaultsOnly` property specifier indicates that the property can be edited by property windows but only on archetypes, not instances.

The `EditInstanceOnly` property specifier indicates that the property can be edited from property windows but only on instances, not archetypes.

The `EditFixedSize` property specifier only applies to dynamic arrays and serves to prevent the user from changing the length of the array from within property windows.

The `EditInline` property specifier allows the user to edit the object property's properties within the property inspector. Primarily useful for object references, including arrays of them.

The `VisibleAnywhere` property specifier indicates that the property be visible in property windows, but not editable.

The `VisibleDefaultsOnly` property specifier indicates that the property be visible in property windows for archetypes, but not editable.

the `VisibleInstanceOnly` property specifier indicates that the property be visible in property windows for instances and not archetypes, but not edible.

The `Export` property specifier only applies to object properties (or arrays of them) and indicates that the object should be deep-copied exported in its entirety as a sub-object block when it's copied, instead of a simple shallow-copy (copying the reference).

The `Instanced` property specifier only applies to object properties and causes any reference assignments to the property to instead reference a unique copy of the assigned object. Primarily useful for instancing sub-objects defined in CDO properties.

The `Interp` property specifier indicates that the value can be interpolated over time by a track in the Matinee editor.

The `Localized` property specifier primarily applies to strings and indicates that the property will have a localized value.

The `Native` property specifier indicates that the property is native, so that native code is responsible for serializing it and exposing it to the garbage collector.

The `NoClear` property specifier prevents the object reference from being nullified from the editor. It hides the "Clear" and "Browse" button.

The `NoExport` property specifier is primarily applies to native classes and indicates that the variable should not be included in the auto-generated class declaration.

The `NonTransactionl` property specifier indicates that changes to the variable should not be included in the Editor's undo history.

The `Ref` property specifier only applies to function parameter declarations and specifies that the value is to be copied out after a function call.

The `Replicated` property specifier indicates that the variable should be replicated.

The `ReplicatedUsing` property specifier indicates that the variable should be replicated and that it should invoke the specified callback when it is received.

The `RepRetry` property specifier primarily applies to structs and instructs the engine to retry a failed replication. This is the default behavior for simple references but not structs due to the bandwidth cost.

The `SaveGame` property specifier indicates that the property should be included in the checkpoint or save system. A proxy archiver is then used to read and write the specified properties.

The `SerializeText` property specifier indicates that the native property should be serialized as text.

The `SimpleDisplay` property specifier indicates that the property should appear in the Details panel.

The `Transient` property specifier indicates that the property is transient and should not be saved. It is zeroed at load time.

# Enumerations

Enumerations can be marked up with the `UENUM` macro. Generally the `BlueprintType` enum specifier is provided to expose the enumeration type to the editor. Individual enumerations can be marked up with the `UMETA` macro, which is useful for setting the `DisplayName` meta specifier, which specifies the name that the enumeration should appear as in the editor.

``` cpp
UENUM(BlueprintType)
enum class EDamageElement : uint8
{
  DE_Earth  UMETA(DisplayName="Earth"),
  DE_Fire   UMETA(DisplayName="Fire"),
  DE_Water  UMETA(DisplayName="Water")
};
```

The `ENUM_CLASS_FLAGS` macro can be used to automatically define all bitwise operators for an enumeration class, _except_ for boolean checks, for which the enumeration must define a `None` enumeration set to `0` which is tested against explicitly.

An enumeration can be marked as a `UPROPERTY` as long as it is based on a `uint8`.

``` cpp
// Old way.
UPROPERTY()
TEnumAsByte<EDamageElement> MyProperty;

// New way.
UPROPERTY()
EDamageElement MyProperty;
```

Fields that should only be accessible by derived classes should be made private with protected accessors.

Classes that should not be derived from should be marked `final`.

# Source vs Launcher

The source must be built in order to build a [standalone dedicated server](https://wiki.unrealengine.com/Standalone_Dedicated_Server).

The engine can be added as a submodule of the game repository, in which case the `.uproject`'s [`EngineAssociation`](https://docs.unrealengine.com/latest/INT/API/Runtime/Projects/FProjectDescriptor/EngineAssociation/index.html) setting must be set to a relative path to that submodule:

> For users which mount the engine through a Git submodule (where the engine is in a subdirectory of the project), this field can be manually edited to be a relative path.

It seems that Epic's own [internal workflow](https://answers.unrealengine.com/questions/43614/uproject-files-engineassociation-saves-a-guid-whic.html) is to embed the game directly within the engine source tree.

# Actors

An actor is an object that can be placed in a level. They support 3D transformation sand can be spawned and destroyed. The base class is `AActor`. Note that although actors support 3D transformations they don't actually store the Transform data. Instead, the Actor's root component's Transform data is used instead.

The `SpawnActor` function can be used to spawn an Actor.

Actors are essentially containers for Components, which control how the Actor moves, renders, etc.

All Actors have the ability to tick each frame or at a user-defined interval so that calculations can be updated or actions performed. Actors tick via the `Tick` function, while ActorComponents tick via `TickComponent`.

Actors are generally not garbage collected since the World Object holst a list of Actor references, but they can be explicitly destroyed via `Destroy`, which removes them from the level and marks them for removal.

An Actor can be loaded from disk when it's already in a level, via `LoadMap` or `AddToWorld`.

1. Actors in a package or level are loaded from the disk
2. `PostLoad` called by serialized Actors when they're finished loading. Custom versioning and fixup occurs here. It's mutually exclusive with `PostActorCreated`.
3. `InitializeActorsForPlay`
4. `RouteActorInitialize` is called for any non-initialized Actor in order to cover seamless travel carry-over.
    1. `PreInitializeComponents` is called before `InitializeComponent` is called on the Actor's Components
    2. `InitializeComponent` is a helper function for the creation of each component defined on the Actor
    3. `PostInitializeComponents` is called after the Actor's components have been initialized.
5. `BeginPlay` is called when the level is started

When an actor is instantiated for Play-in-Editor, the Actors in the Editor are duplicated into a new World and `PostDuplicate` is called, then the process follows as with step #3 of the loading-from-disk process.

When an Actor is spawned, the following process is followed:

1. `SpawnActor` is called
2. `PostSpawnInitialize`
3. `PostActorCreated` is called for spawned Actors after their creation, so initialization go there. It's mutually exclusive with `PostLoad`.
4. `ExecuteConstruction`
    1. `OnConstruction` is the construction of the Actor, where Blueprint Actors create their components and initialize their Blueprint variables
5. `PostActorConstruction`
    1. `PreInitializeComponents` is called before `InitializeComponent` is called on the Actor's Components
    2. `InitializeComponent` is a helper function for the creation of each component defined on the Actor
    3. `PostInitializeComponents` is called after the Actor's components have been initialized.
6. `OnActorSpawned` is broadcast on the `UWorld`
7. `BeginPlay` is called

It's possible for an Actor to be Deferred Spawned by setting any property to "Expose on Spawn." In that case, the following process is followed:

1. `SpawnActorDeferred` is called and is meant to spawn procedural Actors, allowing for additional setup before the Blueprint construction
2. Everything in `SpawnActor` occurs, then after `PostActorCreated`:
    1. Call various initializers with the valid but incomplete Actor instance
    2. `FinishSpawningActor` is called to finalize the Actor
    3. Continue at the `ExecuteConstruction`

The `EndPlay` function guarantees that an Actor's life is coming to an end by marking it as `RF_PendingKill` so that it's removed on the next garbage collection cycle. It is called in many places such as:

* the `Destroy` function
* Play-in-Editor ended
* Level Transitions, be it seamless travel or load map
* when a streaming level containing the Actor is unloaded
* Actor's lifetime has expired
* application shutdown

To check if an Actor is pending kill, an attempt should be made to acquire a weak pointer `FWeakObjectPtr<TheActor>`.

During destruction, while an object is being garbage collected, the following process is followed:

1. `BeginDestroy` is called to allow the Actor to free any resources. Gameplay-related destruction behavior should occur in `EndPlay`
2. `IsReadyForFinishDestroy` is called by the garbage collector to determine whether the object is ready to be deallocated, which means that the object can return `false` to defer its destruction until the next GC pass.
3. `FinishDestroy` is called when the object is finally going to be destroyed and is the final chance to free up internal data structures

